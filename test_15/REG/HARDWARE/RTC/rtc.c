#include "rtc.h"
#include "led.h"
#include "delay.h"
#include "usart.h"

//RTC初始化
//默认尝试使用LSE,当LSE启动失败后,切换为LSI.
//通过BKP寄存器0的值,可以判断RTC使用的是LSE/LSI:
//当BKP0==0X5050时,使用的是LSE
//当BKP0==0X5051时,使用的是LSI
//返回值:0,初始化成功;
//       1,进入初始化模式失败;
//注意:切换LSI/LSE将导致时间/日期丢失,切换后需重新设置.
u8 RTC_Init(void)
{
	u16 ssr;
	u16 bkpflag;
	u16 retry=200;
	u32 tempreg=0;
	
	RCC->APB1ENR|=1<<28;		//使能电源接口时钟
	PWR->CR1|=1<<8;				//后备区域访问使能(RTC+SRAM) 
	bkpflag = RTC_Read_BKR(0);		//读取BKP0的值
	if(bkpflag!=0x5050)
	{
		RCC->CSR|=1<<0;
		while(!(RCC->CSR&0x02));		//LSI RC oscillator not ready
		RCC->BDCR|=1<<0;
		while(retry&&((RCC->BDCR&0X02)==0))
		{
			retry--;
			delay_ms(5);
		}
		tempreg=RCC->BDCR;			//读取BDCR的值
		tempreg&=~(3<<8);			//清零8/9位 
		if(retry==0)tempreg|=1<<9;	//LSE开启失败,启动LSI. 
		else tempreg|=1<<8;			//选择LSE,作为RTC时钟   
		tempreg|=1<<15;				//使能RTC时钟 
		RCC->BDCR=tempreg;			//重新设置BDCR寄存器
		//关闭RTC寄存器写保护
		RTC->WPR=0xCA;
		RTC->WPR=0x53;
		RTC->CR=0;
		if(RTC_Init_Mode())
		{
			RCC->BDCR=1<<16;
			delay_ms(10);
			RCC->BDCR=0;
			return 2;
		}
		RTC->PRER=0xff;
		RTC->PRER|=0x7f<<16;
		RTC->CR&=~(1<<6);
		RTC->ISR&=~(1<<7);
		RTC->WPR=0xff;
		if(bkpflag!=0x5051)
		{
			RTC_Set_Time(23,59,56,0);
			RTC_Set_Date(15,12,27,7);
		}
		if(retry==0)RTC_Write_BKR(0,0x5051);		//LSI
		else RTC_Write_BKR(0,0x5050);		//LSE
	}else
	{
		retry=10;
		ssr=RTC->SSR;
		while(retry)
		{
			delay_ms(10);
			if(ssr==RTC->SSR)retry--;
			else break;
		}
		if(retry==0)
		{
			RTC_Write_BKR(0,0xffff);
			RCC->BDCR=1<<16;
			delay_ms(10);
			RCC->BDCR=0;
		}
	}
	return 0;
}

//RTC时间设置
//hour,min,sec:小时,分钟,秒钟
//ampm:AM/PM,0=AM/24H,1=PM.
//返回值:0,成功
//       1,进入初始化模式失败 
u8 RTC_Set_Time(u8 hour, u8 min, u8 sec, u8 ampm)
{
	u32 temp=0;
	RTC->WPR=0xCA;
	RTC->WPR=0x53;
	if(RTC_Init_Mode()) return 1;
	temp=(((u32)ampm&0x01)<<22)|((u32)RTC_DEC2BCD(hour)<<16)|((u32)RTC_DEC2BCD(min)<<8)|(RTC_DEC2BCD(sec));
	RTC->TR=temp;
	RTC->ISR&=~(1<<7);
	return 0;
}

//RTC日期设置
//year,month,date:年(0~99),月(1~12),日(0~31)
//week:星期(1~7,0,非法!)
//返回值:0,成功
//       1,进入初始化模式失败
u8 RTC_Set_Date(u8 year, u8 month, u8 date, u8 week)
{
	u32 temp=0;
	RTC->WPR=0xCA;
	RTC->WPR=0x53;
	if(RTC_Init_Mode()) return 1;
	temp=(((u32)week&0x07)<<13)|((u32)RTC_DEC2BCD(year)<<16)|((u32)RTC_DEC2BCD(month)<<8)|(RTC_DEC2BCD(date));
	RTC->DR=temp;
	RTC->ISR&=~(1<<7);
	return 0;
}

//获取RTC时间
//*hour,*min,*sec:小时,分钟,秒钟 
//*ampm:AM/PM,0=AM/24H,1=PM.
void RTC_Get_Time(u8 *hour, u8 *min, u8 *sec, u8 *ampm)
{
	u32 temp=0;
	while(RTC_Wait_Synchro());
	temp=RTC->TR;
	*hour=RTC_BCD2DEC((temp>>16)&0x3f);
	*min=RTC_BCD2DEC((temp>>8)&0X7F);
	*sec=RTC_BCD2DEC(temp&0X7F);
	*ampm=temp>>22; 	
}

//获取RTC日期
//*year,*mon,*date:年,月,日
//*week:星期
void RTC_Get_Date(u8 *year,u8 *month,u8 *date,u8 *week)
{
	u32 temp=0;
 	while(RTC_Wait_Synchro());	//等待同步  	 
	temp=RTC->DR;
	*year=RTC_BCD2DEC((temp>>16)&0XFF);
	*month=RTC_BCD2DEC((temp>>8)&0X1F);
	*date=RTC_BCD2DEC(temp&0X3F);
	*week=(temp>>13)&0X07; 
}

//设置闹钟时间(按星期闹铃,24小时制)
//week:星期几(1~7)
//hour,min,sec:小时,分钟,秒钟
void RTC_Set_AlarmA(u8 week, u8 hour, u8 min, u8 sec)
{
	RTC->WPR=0xCA; 
	RTC->WPR=0x53;
	RTC->CR&=~(1<<8);		//关闭闹钟A
	
	while((RTC->ISR&0x01)==0);
	
	RTC->ALRMAR=0;
	RTC->ALRMAR|=1<<30;
	RTC->ALRMAR|=0<<22;
	RTC->ALRMAR|=(u32)RTC_DEC2BCD(week)<<24;
	RTC->ALRMAR|=(u32)RTC_DEC2BCD(hour)<<16;
	RTC->ALRMAR|=(u32)RTC_DEC2BCD(min)<<8;
	RTC->ALRMAR|=(u32)RTC_DEC2BCD(sec);
	
	RTC->ALRMASSR=0;
	RTC->CR|=1<<12;
	RTC->CR|=1<<8;
	RTC->WPR=0xff;
	
	RTC->ISR&=~(1<<8);
	EXTI->PR=1<<17;
	EXTI->IMR|=1<<17;
	EXTI->RTSR|=1<<17;
	MY_NVIC_Init(2,2,RTC_Alarm_IRQn,2); //抢占2，子优先级2，组2 
}

//周期性唤醒定时器设置
//wksel:000,RTC/16;001,RTC/8;010,RTC/4;011,RTC/2;
//      10x,ck_spre,1Hz;11x,1Hz,且cnt值增加2^16(即cnt+2^16)
//注意:RTC就是RTC的时钟频率,即RTCCLK!
//cnt:自动重装载值.减到0,产生中断.
void RTC_Set_WakeUp(u8 wksel, u16 cnt)
{
	RTC->WPR=0xCA; 
	RTC->WPR=0x53;
	RTC->CR&=~(1<<10);		//关闭WAKE UP
	while((RTC->ISR&0x04)==0);
	RTC->CR&=~(7<<0);
	RTC->CR|=wksel&0x07;
	RTC->WUTR=cnt;
	RTC->ISR&=~(1<<10);
	RTC->CR|=1<<14;
	RTC->CR|=1<<10;
	RTC->WPR=0xff;
	
	EXTI->PR=1<<22;  			//清除LINE22上的中断标志位  
	EXTI->IMR|=1<<22;			//开启line22上的中断 
	EXTI->RTSR|=1<<22;			//line22上事件上升降沿触发 
	MY_NVIC_Init(2,2,RTC_WKUP_IRQn,2); //抢占2，子优先级2，组2
}

//RTC闹钟中断服务函数
void RTC_Alarm_IRQHandler(void)
{
	if(RTC->ISR&(1<<8))
	{
		RTC->ISR&=~(1<<8);
		printf("ALARM A!\r\n");
	}
	EXTI->PR|=1<<17;
}

//RTC WAKE UP中断服务函数
void RTC_WKUP_IRQHandler(void)
{
	static u8 led1sta;
	if(RTC->ISR&(1<<10))
	{
		RTC->ISR&=~(1<<10);
		LED1(led1sta^=1);
	}
	EXTI->PR|=1<<22;
}	

//等待RSF同步
//返回：0-成功  1-失败
u8 RTC_Wait_Synchro(void)
{
	u32 retry=0xfffff;
	RTC->WPR=0xca;
	RTC->WPR=0x53;
	RTC->ISR&=~(1<<5);
	while(retry&&((RTC->ISR & (1<<5))==0x00)) retry--;
	if(retry==0) return 1;
	RTC->WPR=0xff;
	return 0;
}

//RTC进入初始化模式
//返回值:0,成功;1,失败;
u8 RTC_Init_Mode(void)
{ 
	u32 retry=0XFFFFF; 
	if(RTC->ISR&(1<<6))return 0; 
	RTC->ISR|=1<<7;	//进入RTC初始化模式
	while(retry&&((RTC->ISR&(1<<6))==0x00))retry--;//等待进入RTC初始化模式成功 
    if(retry==0)return 1;	//同步失败
	else return 0; 			//同步成功 
}
//RTC写入后备区域SRAM
//BKPx:后备区寄存器编号,范围:0~19
//data:要写入的数据,32位长度
void RTC_Write_BKR(u32 BKRx,u32 data)
{
	u32 temp=0; 
	temp=RTC_BASE+0x50+BKRx*4;   
	(*(u32*)temp)=data; 
}
//RTC读取后备区域SRAM
//BKPx:后备区寄存器编号,范围:0~19
//返回值:读取到的数据
u32 RTC_Read_BKR(u32 BKRx)
{
	u32 temp=0; 
	temp=RTC_BASE+0x50+BKRx*4;  
	return (*(u32*)temp);		//返回读取到的值
}

//十进制转换为BCD码
//val:要转换的十进制数
//返回值:BCD码
u8 RTC_DEC2BCD(u8 val)
{
	u8 bcdhigh = 0; 
	while(val>=10)
	{
		bcdhigh++;
		val-=10;
	} 
	return ((u8)(bcdhigh<<4)|val);
}
//BCD码转换为十进制数据
//val:要转换的BCD码
//返回值:十进制数据
u8 RTC_BCD2DEC(u8 val)
{
	u8 temp=0;
	temp=(val>>4)*10;
	return (temp+(val&0X0F));
}

u8 const table_week[12]={0,3,3,6,1,4,6,2,5,0,3,5}; //月修正数据表
//获得现在是星期几
//功能描述:输入公历日期得到星期(只允许1901-2099年)
//year,month,day：公历年月日 
//返回值：星期号(1~7,代表周1~周日)																						 
u8 RTC_Get_Week(u16 year,u8 month,u8 day)
{	
	u16 temp2;
	u8 yearH,yearL;
	yearH=year/100;	yearL=year%100; 
	// 如果为21世纪,年份数加100  
	if (yearH>19)yearL+=100;
	// 所过闰年数只算1900年之后的  
	temp2=yearL+yearL/4;
	temp2=temp2%7; 
	temp2=temp2+day+table_week[month-1];
	if (yearL%4==0&&month<3)temp2--;
	temp2%=7;
	if(temp2==0)temp2=7;
	return temp2;
}
